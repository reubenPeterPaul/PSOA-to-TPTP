grammar TPTP_FOF;

options {
  output = AST;
}

@header {
  package org.ruleml.api.presentation_syntax_parser;
  
  import logic.is.power.tptp_parser.*;
}

@lexer::header {
  package org.ruleml.api.presentation_syntax_parser;
}

fof_formula : fof_logic_formula | fof_sequent ;

fof_logic_formula : fof_binary_formula | fof_unitary_formula ;

fof_binary_formula : fof_binary_nonassoc | fof_binary_assoc ;

fof_binary_nonassoc : fof_unitary_fomrumula binary_connective fof_unitary_formula ;
  
fof_binary_assoc : fof_or_formula | fof_and_formula ;

fof_or_formula : fof_or_formula '|' fof_unitary_formula
  | fof_or_formula '|' fof_unitary_formula ;
  
fof_and_formula : fof_unitary_formula '&' fof_unitary_formula
  | fof_and_formula '&' fof_unitary_formula ;

fof_unitary_formula : fof_quantified_formula | fof_unary_formula | atomic_formula
  | '(' fof_logic_formula ')' ;
  
fof_quantified_formula : fol_quantifier '[' fof_variable_list ']' ':' 
  fof_unitary_formula ;
  
fof_variable_list : variable | variable ',' fof_variable_list ;

fof_unary_formula : unary_connective fof_unitary_formula |
  fol_infix_unary ;

fof_sequent : fof_tuple gentzen_arrow fof_tuple | '(' fof_sequent ')' ;

fof_tuple : '[]' | '[' fof_tuple_list ']' ;

fof_tuple_list : fof_logic_formula | fof_logic_formula ',' fof_tuple_list ;



binary_connective : '<=>' | '=>' | '<=' | '<~>' | '~|' | '~&' ;

fol_quantifier : '!' | '?' ;

gentzen_arrow : '-->' ;

variable : upper_word ;

upper_word : upper_alpha alpha_numeric* ;

// Keywords:

