/* This is a grammar file for PSOA RuleML. Use ANTLR 2.7.x to generate 
 * the parser code.
 */


//--------------------- PARSER: -----------------------

header
{
package org.ruleml.api.presentation_syntax_parser;

import java.util.*;
}


class RuleMLPresentationSyntaxParser extends Parser;
options
{
    exportVocab = RuleMLPresentationSyntax;
    defaultErrorHandler = false;
}

top_level_item [AbstractSyntax factory]
returns [AbstractSyntax.Document doc = null]
    : doc = document[factory]
    | EOF
    ;


document  [AbstractSyntax factory]
returns [AbstractSyntax.Document result]
{
    AbstractSyntax.Base base;
    Iterable<AbstractSyntax.Prefix> prefixes;
    Iterable<AbstractSyntax.Import> imports;
}
    : 
        kw:DOCUMENT 
        (
            LPAR
            base = base[factory]
            prefixes = prefixes[factory]
            imports = imports[factory]
            group = group[factory]
            RPAR
            {
                result = 
                factory.createDocument(base,
                                       prefixes,
                                       imports,
                                       group);
            }
        )
        | 
        {            
            throw new antlr.RecognitionException("Not a well-formed document", 
                                                 getFilename(), 
                                                 kw.getLine(), 
                                                 kw.getColumn());
        }        
    ;


base [AbstractSyntax factory]
returns [AbstractSyntax.Base result]
    :
        kw:BASE 
        (
            LPAR LESS iri:IRI GREATER RPAR
            {
                result = factory.createBase(iri.getText());           
            }
        |   
            {
                throw new antlr.RecognitionException("Not a well-formed base directive", 
                                                     getFilename(), 
                                                     kw.getLine(), 
                                                     kw.getColumn());
            }
        )
        |
        /* anything else */
        {
            result = null;
        }
    ;


prefixes [AbstractSyntax factory]
returns [Iterable<AbstractSyntax.Prefix> result]
{
    AbstractSyntax.Prefix prefix;
}
    : /* empty */
        { result =  new LinkedList<AbstractSyntax.Prefix>(); }
    |
        prefix = prefix[factory]
        result = prefixes[factory]
        {
            result.addFirst(prefix);
        }
    ;   



prefix [AbstractSyntax factory]
returns [AbstractSyntax.Prefix result]
    :
        kw:PREFIX 
        (
            LPAR 
            name = name[factory]
            LESS
            iri:IRI 
            GREATER 
            RPAR
            {
                result = factory.createPrefix(name,iri.getText());           
            }        
            | 
            {
                throw new antlr.RecognitionException("Not a well-formed prefix directive", 
                                                     getFilename(), 
                                                     kw.getLine(), 
                                                     kw.getColumn());
            }    
        )
    ;





imports  [AbstractSyntax factory]
returns [Iterable<AbstractSyntax.Import> result]
{
    AbstractSyntax.Import import;
}
    : /* empty */
        { result =  new LinkedList<AbstractSyntax.Import>(); }
    |
        import = import[factory]
        result = imports[factory]
        {
            result.addFirst(import);
        }
    ;   




import [AbstractSyntax factory]
returns [AbstractSyntax.Import result]
{
    AbstractSyntax.Profile profile;
}
    :
        kw:IMPORT 
        (
            LPAR             
            LESS
            iri:IRI
            profile=profile[factory] 
            GREATER 
            RPAR
            {
                result = factory.createImport(iri.getText(),profile);           
            }        
            | 
            {
                throw new antlr.RecognitionException("Not a well-formed import directive", 
                                                     getFilename(), 
                                                     kw.getLine(), 
                                                     kw.getColumn());
            }    
        )
    ;







group [AbstractSyntax factory]
returns [AbstractSyntax.Group result]
{
    Iterable<AbstractSyntax.GroupElement> elements; 
}
    :
        kw:GROUP 
        (
            LPAR 
            LESS iri:IRI 
            GREATER
            elements = group_elements[factory]
            RPAR
            {
                result = factory.createGroup(elements);           
            }
            |       
            {       
                throw new antlr.RecognitionException("Not a well-formed group", 
                                                     getFilename(), 
                                                     kw.getLine(), 
                                                     kw.getColumn());
            }
        )
    ;






group_elements  [AbstractSyntax factory]
returns [Iterable<AbstractSyntax.GroupElement> result]
{
    AbstractSyntax.GroupElement element;
}
    : /* empty */
        { result =  new LinkedList<AbstractSyntax.GroupElement>(); }
    |
        element = group_element[factory]
        result = group_elements[factory]
        {
            result.addFirst(element);
        }
    ;   




group_element [AbstractSyntax factory]
returns [AbstractSyntax.GroupElement result]
    :
        result = rule[factory]
    |
        result = group[factory]
    ;


rule [AbstractSyntax factory]
returns [AbstractSyntax.Rule result]
    :
        kw:FORALL 
        (
            vars = nonempty_vars[factory]
            LPAR
            matrix = clause[factory]
            RPAR
            {
                result = factory.createRule(vars,matrix);
            }        
            |       
            {
                
                throw new antlr.RecognitionException("Not a well-formed (universally quantified) rule", 
                                                     getFilename(), 
                                                     kw.getLine(), 
                                                     kw.getColumn());
            }
        )
    |
        matrix = clause[factory]
        {
            result = factory.createRule(null,matrix);
        }
    ;




nonempty_vars  [AbstractSyntax factory]
returns [Iterable<AbstractSyntax.Var> result]
{
    AbstractSyntax.Var var;
}
    :
        var = var[factory]
        (
            /* empty */
            {
                result = new LinkedList<AbstractSyntax.Var>();
                result.addFirst(var);
            }
        |
            result = vars[factory]
            {
                result.addFirst(var);
            }
        )      
    ;   



vars  [AbstractSyntax factory]
returns [Iterable<AbstractSyntax.Var> result]
{
    AbstractSyntax.Var var;
}
    : /* empty */
        { result =  new LinkedList<AbstractSyntax.Var>(); }
    |
        var = var[factory]
        result = vars[factory]
        {
            result.addFirst(var);
        }
    ;   



clause [AbstractSyntax factory]
returns [AbstractSyntax.Clause result]
    :
        result = implies[factory]
    |
        result = atomic[factory]
    ;



implies [AbstractSyntax factory]
returns [AbstractSyntax.Implies result] 
{
    Iterable<AbstractSyntax.Head> heads;
    AbstractSyntax.Formula condition;
}
    :
        heads = head_conjunction[factory]
        kw:IMPLICATION
        (
            condition = formula[factory]
            {
                result = factory.createImplies(heads,condition);
            }
            |                   
            {
                
                throw new antlr.RecognitionException("Not a well-formed implication condition", 
                                                     getFilename(), 
                                                     kw.getLine(), 
                                                     kw.getColumn());
            }
        )
   
    ;


head_conjunction  [AbstractSyntax factory]
returns [Iterable<AbstractSyntax.Head> result]
{
    AbstractSyntax.Head head;
}
    :
        head = head[factory]
        {
            result = new LinkedList<AbstractSyntax.Head>();
            result.addFirst(head);
        }
    |
        kw:AND
        (
            LPAR
            result = heads[factory]
            RPAR
            {
            }                  
            |       
            {
                
                throw new antlr.RecognitionException("Not a well-formed conjunctive rule head", 
                                                     getFilename(), 
                                                     kw.getLine(), 
                                                     kw.getColumn());
            }
        )
    ;

        

heads  [AbstractSyntax factory]
returns [Iterable<AbstractSyntax.Head> result]
{
    AbstractSyntax.Head head;
}
    : /* empty */
        { result =  new LinkedList<AbstractSyntax.Head>(); }
    |
        head = head[factory]
        result = heads[factory]
        {
            result.addFirst(head);
        }
    ;   



head [AbstractSyntax factory]
returns [AbstractSyntax.Head result]
    :
        kw:EXISTS 
        (
            vars = nonempty_vars[factory]
            LPAR
            matrix = atomic[factory]
            RPAR
            {
                result = factory.createHead(vars,matrix);
            }        
            |  
            {
                
                throw new antlr.RecognitionException("Not a well-formed (existentially quantified) head", 
                                                     getFilename(), 
                                                     kw.getLine(), 
                                                     kw.getColumn());
            }
        )
    |
        matrix = atomic[factory]
        {
            result = factory.createHead(null,matrix);
        }
    ;




profile [AbstractSyntax factory]
returns [AbstractSyntax.Profile result]
    :
        LESS
        iri:IRI
        GREATER
        {
            result = factory.createProfile(iri.getText());
        }
    | /* anything else */
        {
            result = null;
        }
    ;


formula [AbstractSyntax factory]
returns [AbstractSyntax.Formula result]
    :
        result = formula_and[factory]
    |
        result = formula_or[factory]
    |
        result = formula_exists[factory]
    |
        result = atomic[factory]
    |
        result = formula_externa[factory]
    ;



formula_and [AbstractSyntax factory]
returns [AbstractSyntax.Formula_And result]
    :
        kw:AND
        (
            LPAR
            formulas = formulas[factory]
            RPAR
            {
                result = factory.createFormula_And(formulas);
            }            
            |
            {            
                throw new antlr.RecognitionException("Not a well-formed conjunction", 
                                                     getFilename(), 
                                                     kw.getLine(), 
                                                     kw.getColumn());
            }                        
        )
    ;


formula_or [AbstractSyntax factory]
returns [AbstractSyntax.Formula_Or result]
    :
        kw:OR
        (
            LPAR
            formulas = formulas[factory]
            RPAR
            {
                result = factory.createFormula_Or(formulas);
            }            
            |
            {            
                throw new antlr.RecognitionException("Not a well-formed disjunction", 
                                                     getFilename(), 
                                                     kw.getLine(), 
                                                     kw.getColumn());
            }                        
        )
    ;




formula_exists [AbstractSyntax factory]
returns [AbstractSyntax.Formula_Exists result]
{
    Iterable<AbstractSyntax.Var> vars;
    AbstractSyntax.Formula matrix;
}
    :
        kw:EXISTS
        (
            vars = nonempty_vars[factory]
            LPAR
            matrix = formula[factory]
            RPAR
            {
                result = factory.createFormula_Exists(vars,matrix);
            }            
            |
            {            
                throw new antlr.RecognitionException("Not a well-formed existentially quantified formula", 
                                                     getFilename(), 
                                                     kw.getLine(), 
                                                     kw.getColumn());
            }                        
        )
    ;



formula_external [AbstractSyntax factory]
returns [AbstractSyntax.Formula_External result]
{
    AbstractSyntax.Atom atom;
}
    :
        kw:EXTERNAL
        (
            LPAR
            atom = atom[factory]
            RPAR
            {
                result = factory.createFormula_External(atom);
            }            
            |
            {            
                throw new antlr.RecognitionException("Not a well-formed 'External' formula", 
                                                     getFilename(), 
                                                     kw.getLine(), 
                                                     kw.getColumn());
            }                        
        )
    ;
        

atomic [AbstractSyntax factory]
returns [AbstractSyntax.Atomic result]
    :
        result = atom[factory]
    |
        result = equal[factory]
    |
        result = subclass[factory]
    ;


atom [AbstractSyntax factory]
returns [AbstractSyntax.Atom result]
{
    AbstractSyntax.Psoa term;
}
    :
        term = psoa[factory]
        {
            result = factory.createAtom(term);
        }

    ;


equal [AbstractSyntax factory]
returns [AbstractSyntax.Equal result]
{
    AbstractSyntax.Term lhs;
    AbstractSyntax.Term rhs;    
}
    :
      lhs = term[factory]
      kw:EQUAL     
        (
            rhs = term[factory]
            {
                result = factory.createEqual(lhs,rhs);
            }            
            |
            {            
                throw new antlr.RecognitionException("Cannot parse the second equality argument term", 
                                                     getFilename(), 
                                                     kw.getLine(), 
                                                     kw.getColumn());
            }                        
        )
    ;  



subclass [AbstractSyntax factory]
returns [AbstractSyntax.Subclass result]
{
    AbstractSyntax.Term lhs;
    AbstractSyntax.Term rhs;    
}
    :
      lhs = term[factory]
      kw:SUBCLASS     
        (
            rhs = term[factory]
            {
                result = factory.createSubclass(lhs,rhs);
            }            
            |
            {            
                throw new antlr.RecognitionException("Cannot parse the second argument term in a subclass formula", 
                                                     getFilename(), 
                                                     kw.getLine(), 
                                                     kw.getColumn());
            }                        
        )
    ;  





psoa [AbstractSyntax factory]
returns [AbstractSyntax.Psoa result]
{
    AbstractSyntax.Term object;
    AbstractSyntax.Term classTerm;   
    Iterable<AbstractSyntax.Tuple> tuples;
    Iterable<AbstractSyntax.Slot> slots;
}
    :
        object = term[factory]
        kw:INSTANCE 
        (
            classTerm = term[factory]
            LPAR
            tuples = tuples[factory]
            slots = slots[factory]
            RPAR
            {
                result = factory.createPsoa(object,
                                            classTerm,
                                            tuples,
                                            slots);
            }            
            |
            {            
                throw new antlr.RecognitionException("Not a well-formed PSOA term", 
                                                     getFilename(), 
                                                     kw.getLine(), 
                                                     kw.getColumn());
            }                        
        )
    ;  



tuples  [AbstractSyntax factory]
returns [Iterable<AbstractSyntax.Tuple> result]
{
    AbstractSyntax.Tuple tuple;
}
    : /* empty */
        { result =  new LinkedList<AbstractSyntax.Tuple>(); }
    |
        tuple = tuple[factory]
        result = tuples[factory]
        {
            result.addFirst(tuple);
        }
    ;   


tuple  [AbstractSyntax factory]
returns [AbstractSyntax.Tuple result]
{
    Iterable<AbstractSyntax.Tuple> terms;
}
    : 
        kw:LSQBR 
        (
            terms = terms[factory]
            RSQBR
            {
                result = factory.createTuple(terms);
            }            
            |
            {            
                throw new antlr.RecognitionException("Not a well-formed tuple", 
                                                     getFilename(), 
                                                     kw.getLine(), 
                                                     kw.getColumn());
            }                        
        )
    ;  

      


slots  [AbstractSyntax factory]
returns [Iterable<AbstractSyntax.Slot> result]
{
    AbstractSyntax.Slot slot;
}
    : /* empty */
        { result =  new LinkedList<AbstractSyntax.Slot>(); }
    |
        slot = slot[factory]
        result = slots[factory]
        {
            result.addFirst(slot);
        }
    ;   



slot [AbstractSyntax factory]
returns [AbstractSyntax.Slot result]
{
    AbstractSyntax.Term name;
    AbstractSyntax.Term value;    
}
    :
      name = term[factory]
      kw:SLOT_ARROW     
        (
            value = term[factory]
            {
                result = factory.createSlot(name,value);
            }                
            |
            {                
                throw new antlr.RecognitionException("Cannot parse the slot value term", 
                                                     getFilename(), 
                                                     kw.getLine(), 
                                                     kw.getColumn());
            }                        
        )
    ;  


term [AbstractSyntax factory]
returns [AbstractSyntax.Term result]
    :
        result = const[factory]
    |
        result = var[factory]
    |
        result = psoa[factory]
    |
        result = external[factory]
    ;





const [AbstractSyntax factory]
returns [AbstractSyntax.Const result]
    :
        result = const_literal[factory]
    |
        result = const_constshort[factory]
    ;


const_literal [AbstractSyntax factory]
returns [AbstractSyntax.Const_Literal result]
{
    AbstractSyntax.Symspace symspace;
}
    :
        content:STRING 
        SYMSPACE_OPER
        symspace = symspace[factory]
        {
            result = factory.createConst_Literal(content.getText(),
                                                 symspace);
        }
    ;
    
const_constshort  [AbstractSyntax factory]
returns [AbstractSyntax.Const_Constshort result]
    :
        name:ID // temporary. What is CONSTSHORT?
        {
            return factory.createConst_Constshort(name.getText());
        }
    ;




var [AbstractSyntax factory]
returns [AbstractSyntax.Var result]
    :
    QUESTION_MARK
        (    
            name:ALPHA_NUM_ID
            {
                result = factory.createVar(name.getText());
            }
            | /* empty */            
            {
                result = factory.createVar(null);
            }                       
        )
    ;  


        
//--------------------- LEXER: -----------------------
            

 
class TptpLexer extends Lexer;      
options
  {
    k = 2;
    exportVocab = RuleMLPresentationSyntax; 
    testLiterals = false;
    charVocabulary = '\0'..'\377';
    defaultErrorHandler=false;
  } 
  {
    public void incrLine() {newline(); /* ANTLR's function*/ }
  }




//   Comments and whitespace:

SINGLE_LINE_COMMENT
        : "//" (~('\n'|'\r') )*    {$setType(Token.SKIP);}
        ;
MULTI_LINE_COMMENT
        : "/*"
          ( options {greedy=false;} :
            '*'
            | ("\r\n") => "\r\n"    { incrLine(); }
            | ( '\n' | '\r' )       { incrLine(); }
            | ~( '*'| '\r' | '\n' )
          )*
          "*/"       {$setType(Token.SKIP);}
       ;

WHITESPACE
        : (('\003'..'\010' 
            | '\t' 
            | '\013' // same as '\v' 
            | '\f' 
            | '\016'.. '\037' 
            | '\177'..'\377' 
            | ' ')
           | ("\r\n" | '\n' | '\r' )  { incrLine(); }
          ) { $setType(Token.SKIP); }
        ;




//   Identifiers:

// Currently, only URIs are implemented (RFC 3986). And only the most popular
// forms of URIs.

IRI 
    : IRI_SCHEME 
      ':' 
      IRI_HIER_PART 
      ('?' IRI_QUERY | )
      ('#' IRI_FRAGMENT )
    ;  

IRI_SCHEME 
    : ('A'..'Z' | 'a'..'z')('a'..'z' | '0'..'9' | 'A'..'Z'| '+' | '-' | '.')*
    ;  

IRI_HIER_PART 
    : ("//" IRI_AUTHORITY IRI_PATH_ABEMPTY)
      | PATH_ABSOLUTE
      | PATH_ROOTLESS
      | /* empty */
    ;  
    
IRI_AUTHORITY : (IRI_USER_INFO '@' | ) IRI_HOST (':' IRI_PORT) ;

IRI_USER_INFO : (UNRESERVED | PCT_ENCODED | SUB_DELIMS | ':')* ;
      
UNRESERVED : 'a'..'z' | '0'..'9' | 'A'..'Z'| '-' | '.' | "_" | "~" ;

PCT_ENCODED : '%' HEXDIG HEXDIG ;

HEXDIG : 'a'..'f' | '0'..'9' | 'A'..'F' ;

SUB_DELIMS : '!' | '$' | '&' | "'" | '(' | ')' | '*' | '+' | ',' | ';' | '=' ;


// The option IP-literal is not implemented yet.
IRI_HOST : IP_V_4_ADDRESS | REG_NAME ;


IP_V_4_ADDRESS : DEC_OCTET '.' DEC_OCTET '.' DEC_OCTET '.' DEC_OCTET ;

DEC_OCTET : '0'..'9' 
          | '1'..'9' '0'..'9' 
          | '1'  '0'..'9' '0'..'9'
          | '2' ('0'..'4' '0'..'9' | '5' '0'..'5')
          ;   

REG_NAME : (UNRESERVED | PCT_ENCODED | SUB_DELIMS)* ;




ALPHA_NUM_ID
    : ('A'..'Z' | 'a'..'z')('a'..'z' | '0'..'9' | 'A'..'Z'| '_')*
    ;  
    

//   Constants:
STRING 
       : "\"" 
         ( '\40'..'\46' | '\50'..'\133' | '\135'..'\176'
           | '\\' ('\\'|"\"")  // "\" can be followed by "\" or "\"" only.
         )*
         "\""
       ;

//   Keywords:

DOCUMENT : "Document";
BASE : "Base";
PREFIX : "Prefix"; 
IMPORT : "Import"; 
GROUP : "Group";
FORALL : "Forall"; 
EXISTS : "Exists"; 
AND : "And";
OR : "Or";
EXTERNAL : "External";

//   Operators:
IMPLICATION : ":-";
EQUAL : "=";
SUBCLASS : "##";
INSTANCE : "#";
SLOT_ARROW : "->";
SYMSPACE_OPER : "^^";


//   Punctuation:
LPAR : "(" ;
RPAR : ")" ;
LESS : "<" ;
GREATER : ">" ;
LSQBR : "[" ;
RSQBR : "]" ;
QUESTION_MARK : "?" ;



