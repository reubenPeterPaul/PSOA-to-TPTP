/* This is a grammar file for PSOA RuleML. Use ANTLR 2.7.x to generate 
 * the parser code.
 */


//--------------------- PARSER: -----------------------

header
{
package org.ruleml.api.presentation_syntax_parser;

import org.ruleml.api.*;

import java.util.*;
}


class RuleMLPresentationSyntaxParser extends Parser;
options
{
    //k = 2;
    exportVocab = RuleMLPresentationSyntax;
    defaultErrorHandler = false;
}


top_level_item [AbstractSyntax factory]
returns [AbstractSyntax.Document doc = null]
    : doc = document[factory]
        {
        }
    | EOF 
        {
        }
    ;


base [AbstractSyntax factory]
returns [AbstractSyntax.Base result]
    :
        BASE LPAR iri:IRI_REF RPAR
        {
            // later we should check if iri parses as an IRI
            result = factory.createBase(iri.getText());           
        }     
    ;



prefixes [AbstractSyntax factory]
returns [Iterable<AbstractSyntax.Prefix> result]
{
    AbstractSyntax.Prefix prefix;
}
    : /* empty */
        { result =  new LinkedList<AbstractSyntax.Prefix>(); }
    |
        prefix = prefix[factory]
        result = prefixes[factory]
        {
            ((LinkedList<AbstractSyntax.Prefix>)result).addFirst(prefix);
        }
    ;   


prefix [AbstractSyntax factory]
returns [AbstractSyntax.Prefix result]
    :
        kw:PREFIX LPAR name:ID iri:IRI_REF RPAR
        {
            // later we should check if iri parses as an IRI
            // and name parses as a prefix
            AbstractSyntax.Name nameObj= factory.createName(name.getText());
            result = factory.createPrefix(nameObj,iri.getText());           
        }     
    ;




imports  [AbstractSyntax factory]
returns [Iterable<AbstractSyntax.Import> result]
{
    AbstractSyntax.Import imp;
}
    : /* empty */
        { result =  new LinkedList<AbstractSyntax.Import>(); }
    |
        imp = importDecl[factory]
        result = imports[factory]
        {
            ((LinkedList<AbstractSyntax.Import>)result).addFirst(imp);
        }
    ;   




importDecl [AbstractSyntax factory]
returns [AbstractSyntax.Import result]
{
}
    :
        kw:IMPORT LPAR iri:IRI_REF (profile:IRI_REF)? RPAR
            {
                // later we should check if iri and profile can be parsed as IRIs
                
                AbstractSyntax.Profile profileObj =
                    (profile != null)?
                    factory.createProfile(profile.getText())
                    :
                    null;
                result = factory.createImport(iri.getText(),profileObj);           
            } 
        
    ;



document  [AbstractSyntax factory]
returns [AbstractSyntax.Document result]
{
    AbstractSyntax.Base base = null;
    Iterable<AbstractSyntax.Prefix> prefixes;
    Iterable<AbstractSyntax.Import> imports;
    AbstractSyntax.Group group = null;
}
    : 
        kw:DOCUMENT 
        LPAR
        (base = base[factory])?
        prefixes = prefixes[factory]
        imports = imports[factory]
        (group = group[factory])?
        RPAR
        {
            result = 
            factory.createDocument(base,
                                   prefixes,
                                   imports,
                                   group);
        } 
    ;



group [AbstractSyntax factory]
returns [AbstractSyntax.Group result]
{
    Iterable<AbstractSyntax.GroupElement> elements; 
}
    :
        kw:GROUP 
        LPAR 
        elements = group_elements[factory]
        RPAR
        {
            result = factory.createGroup(elements);           
        }
    ;



group_elements  [AbstractSyntax factory]
returns [Iterable<AbstractSyntax.GroupElement> result]
{
    AbstractSyntax.GroupElement element;
}
    : /* empty */
        { result =  new LinkedList<AbstractSyntax.GroupElement>(); }
    |
        element = group_element[factory]
        result = group_elements[factory]
        {
            ((LinkedList<AbstractSyntax.GroupElement>)result).addFirst(element);
        }
    ;   



group_element [AbstractSyntax factory]
returns [AbstractSyntax.GroupElement result]
    :
        result = rule[factory]
        {
        }
    |
        result = group[factory]
        {
        }
    ;

rule [AbstractSyntax factory]
returns [AbstractSyntax.Rule result]
{
  Iterable<AbstractSyntax.Var> vars;
  AbstractSyntax.Clause matrix;
  
}
    :
        kw:FORALL 
        vars = nonempty_vars[factory]
        LPAR
        matrix = clause[factory]
        RPAR
        {
            result = factory.createRule(vars,matrix);
        }  
    |
        matrix = clause[factory]
        {
            result = factory.createRule(null,matrix);
        }
    ;




nonempty_vars  [AbstractSyntax factory]
returns [Iterable<AbstractSyntax.Var> result]
{
    AbstractSyntax.Var var;
}
    :
        var = var[factory]
        result = vars[factory]
        {
            ((LinkedList<AbstractSyntax.Var>)result).addFirst(var);
        }
    ;   


vars  [AbstractSyntax factory]
returns [Iterable<AbstractSyntax.Var> result]
{
    AbstractSyntax.Var var;
}
    :  var = var[factory]
       result = vars[factory]
        {
            ((LinkedList<AbstractSyntax.Var>)result).addFirst(var);
        }
    | /* empty */
        { result =  new LinkedList<AbstractSyntax.Var>(); }
    ;   


var [AbstractSyntax factory]
returns [AbstractSyntax.Var result]
    : name:VAR_ID 
        {
            if (name.getText().equals("?"))
                {
                    result = factory.createVar(null);
                }
            else 
                result = factory.createVar(name.getText());
        }
    ;  



clause [AbstractSyntax factory]
returns [AbstractSyntax.Clause result]
{
    AbstractSyntax.Implies implies;
    AbstractSyntax.Atomic atomic;
}
    :
        implies = implies[factory]
        {
            result = factory.createClause(implies);
        }
    |
        atomic = atomic[factory]
        {
            result = factory.createClause(atomic);
        }
    ;


implies [AbstractSyntax factory]
returns [AbstractSyntax.Implies result] 
{
    Iterable<AbstractSyntax.Head> heads;
    AbstractSyntax.Formula condition;
}
    :
        heads = head_conjunction[factory]
        kw:IMPLICATION
        condition = formula[factory]
        {
            result = factory.createImplies(heads,condition);
        }
    ;


head_conjunction  [AbstractSyntax factory]
returns [Iterable<AbstractSyntax.Head> result]
{
    AbstractSyntax.Head head;
}
    :
        head = head[factory]
        {
            result = new LinkedList<AbstractSyntax.Head>();
            ((LinkedList<AbstractSyntax.Head>)result).addFirst(head);
        }
    |
        kw:AND
        LPAR
        result = heads[factory]
        RPAR
        {
        }                  
         
    ;



heads  [AbstractSyntax factory]
returns [Iterable<AbstractSyntax.Head> result]
{
    AbstractSyntax.Head head;
}
    : /* empty */
        { result =  new LinkedList<AbstractSyntax.Head>(); }
    |
        head = head[factory]
        result = heads[factory]
        {
            ((LinkedList<AbstractSyntax.Head>)result).addFirst(head);
        }
    ;   



head [AbstractSyntax factory]
returns [AbstractSyntax.Head result]
{
  Iterable<AbstractSyntax.Var> vars; 
  AbstractSyntax.Atomic matrix;
}
    :
        kw:EXISTS 
        vars = nonempty_vars[factory]
        LPAR
        matrix = atomic[factory]
        RPAR
        {
            result = factory.createHead(vars,matrix);
        }     
    |
        matrix = atomic[factory]
        {
            result = factory.createHead(null,matrix);
        }
    ;



atomic [AbstractSyntax factory]
returns [AbstractSyntax.Atomic result]
{
}
    :
        result = equal[factory]
        {
        }
    |
        result = subclass[factory]
        {
        }
    |
        result = atom[factory]
        {
        }
    ;


atom [AbstractSyntax factory]
returns [AbstractSyntax.Atom result]
{
    AbstractSyntax.Psoa term;
}
    :
        term = psoa[factory]
        {
            result = factory.createAtom(term);
        }

    ;




equal [AbstractSyntax factory]
returns [AbstractSyntax.Equal result]
{
    AbstractSyntax.Term lhs;
    AbstractSyntax.Term rhs;    
}
    :
      lhs = closed_term[factory]
      kw:EQUAL   
      rhs = closed_term[factory]
        {
            result = factory.createEqual(lhs,rhs);
        }  
    ;  





subclass [AbstractSyntax factory]
returns [AbstractSyntax.Subclass result]
{
    AbstractSyntax.Term lhs;
    AbstractSyntax.Term rhs;    
}
    :
      lhs = closed_term[factory]
      kw:SUBCLASS     
      rhs = closed_term[factory]
        {
            result = factory.createSubclass(lhs,rhs);
        }   
    ;  





tuples  [AbstractSyntax factory]
returns [Iterable<AbstractSyntax.Tuple> result]
{
    AbstractSyntax.Tuple tuple;
}
    : /* empty */
        { result =  new LinkedList<AbstractSyntax.Tuple>(); }
    |
        tuple = tuple[factory]
        result = tuples[factory]
        {
            ((LinkedList<AbstractSyntax.Tuple>)result).addFirst(tuple);
        }
    ;   



tuple  [AbstractSyntax factory]
returns [AbstractSyntax.Tuple result]
{
    Iterable<AbstractSyntax.Term> terms;
}
    : 
        kw:LSQBR 
        terms = terms[factory]
        RSQBR
        {
            result = factory.createTuple(terms);
        }  
    ;  



slots  [AbstractSyntax factory]
returns [Iterable<AbstractSyntax.Slot> result]
{
    AbstractSyntax.Slot slot;
}
    : /* empty */
        { result =  new LinkedList<AbstractSyntax.Slot>(); }
    |
        slot = slot[factory]
        result = slots[factory]
        {
            ((LinkedList<AbstractSyntax.Slot>)result).addFirst(slot);
        }
    ;   



slot [AbstractSyntax factory]
returns [AbstractSyntax.Slot result]
{
    AbstractSyntax.Term name;
    AbstractSyntax.Term value;    
}
    :
      name = term[factory]
      kw:SLOT_ARROW     
      value = term[factory]
        {
            result = factory.createSlot(name,value);
        }   
    ;  



closed_term [AbstractSyntax factory]
returns [AbstractSyntax.Term result]
{
}
    :
       result  = constant[factory]
        {
        }
    |
        result = var[factory]
        {
        }
    |
        LPAR result = term[factory] RPAR
        {
        }
/*
    |
        result = external[factory]
        {
        }
*/
    ;

term [AbstractSyntax factory]
returns [AbstractSyntax.Term result]
{
}
    :
        result = psoa[factory]
        {
        }
    |
       result  = closed_term[factory]
        {
        }
/*
    |
        result = external[factory]
        {
        }
*/
    ;


psoa [AbstractSyntax factory]
returns [AbstractSyntax.Psoa result]
{
    AbstractSyntax.Term object;
    AbstractSyntax.Term classTerm = null;   
    Iterable<AbstractSyntax.Tuple> tuples;
    Iterable<AbstractSyntax.Slot> slots;
}
    :
        object = closed_term[factory]
        (kw:INSTANCE classTerm = closed_term[factory])?
        LPAR
        tuples = tuples[factory]
        slots = slots[factory]
        RPAR
        {
            result = factory.createPsoa(object,
                                        classTerm,
                                        tuples,
                                        slots);
        }    
    ;  


constant [AbstractSyntax factory]
returns [AbstractSyntax.Const result]
{
}
    :
        result = const_literal[factory]
        {
        }
    |
        result = const_constshort[factory]
        {
        }
    ;



const_literal [AbstractSyntax factory]
returns [AbstractSyntax.Const_Literal result]
{
    AbstractSyntax.Symspace symspace;
}
    :
        content:STRING 
        SYMSPACE_OPER
        symspace = symspace[factory]
        {
            result = factory.createConst_Literal(content.getText(),
                                                 symspace);
        }
    ;
    
const_constshort  [AbstractSyntax factory]
returns [AbstractSyntax.Const_Constshort result]
    :
        name:ID // temporary, has to be refined
        {
            result = factory.createConst_Constshort(name.getText());
        }
    ;




terms  [AbstractSyntax factory]
returns [Iterable<AbstractSyntax.Term> result]
{
    AbstractSyntax.Term term;
}
    : /* empty */
        { result =  new LinkedList<AbstractSyntax.Term>(); }
    |
        term = term[factory]
        result = terms[factory]
        {
            ((LinkedList<AbstractSyntax.Term>)result).addFirst(term);
        }
    ;   


symspace [AbstractSyntax factory]
returns [AbstractSyntax.Symspace result]
   : iri:IRI 
        {
            result = factory.createSymspace(iri.getText());
        }
    | curie:ID
        {
            result = factory.createSymspace(iri.getText());
        } 
    ;
 
 


formula [AbstractSyntax factory]
returns [AbstractSyntax.Formula result]
    : ID { result = null;  }
    ;
        
//--------------------- LEXER: -----------------------
            

 
class  RuleMLPresentationSyntaxLexer extends Lexer;      
options
  {
    k = 6;
    exportVocab = RuleMLPresentationSyntax; 
    testLiterals = false;
    charVocabulary = '\0'..'\377';
    defaultErrorHandler=false;
  } 
  {
    public void incrLine() {newline(); /* ANTLR's function*/ }
  }




//   Comments and whitespace:


// Must be after PN_PREFIX
WHITESPACE
        : (('\003'..'\010' 
            | '\t' 
            | '\013' // same as '\v' 
            | '\f' 
            | '\016'.. '\037' 
            | '\177'
            | ' ')
           | ("\r\n" | '\n' | '\r' )  { incrLine(); }
          ) { $setType(Token.SKIP); }
        ;

MULTI_LINE_COMMENT
        : "<!--"
          ( options {greedy=false;} :
            '*'
            | ("\r\n") => "\r\n"    { incrLine(); }
            | ( '\n' | '\r' )       { incrLine(); }
            | ~( '*'| '\r' | '\n' )
          )*
          "-->"       {$setType(Token.SKIP);}
       ;


// Keywords:


DOCUMENT : "Document" ; 

BASE : "Base" ; 

IMPORT : "Import" ; 

PREFIX : "Prefix" ; 

GROUP : "Group" ; 

FORALL : "Forall" ; 

EXISTS : "Exists" ; 

AND : "And" ; 


//   Identifiers:

IRI_REF : '<' IRI_START_CHAR (IRI_CHAR)+ '>' ;


ID : ID_START_CHAR (ID_CHAR)* ; 

VAR_ID : '?' (ID_CHAR)* ; 

//   Constants:
STRING 
       : "\"" 
         ( '\40'..'\46' | '\50'..'\133' | '\135'..'\176'
           | '\\' ('\\'|"\"")  // "\" can be followed by "\" or "\"" only.
         )*
         "\""
       ;

//   Operators:
IMPLICATION : ":-";
EQUAL : "=";
SUBCLASS : "##";
INSTANCE : "#";
SLOT_ARROW : "->";
SYMSPACE_OPER : "^^";


//   Punctuation:
LPAR : "(" ;
RPAR : ")" ;
LESS : "<" ;
GREATER : ">" ;
LSQBR : "[" ;
RSQBR : "]" ;
//QUESTION_MARK : "?" ;





//  Basics

protected ALPHA : 'a'..'z' | 'A'..'Z' ;

protected DIGIT : '0'..'9' ;


protected IRI_CHAR : ALPHA | DIGIT | '+' | '-' | '.' | '@' | ':' | '_' | '~' | '%' | '!' |  '$' | '&' | "'" | '(' | ')' | '*' | ',' | ';' | '=' | '?' | '#' | '/';
// Currently, these are only URI characters. The set has to be extended
// to include all IRI characters.


protected IRI_START_CHAR : ALPHA ;


protected ID_CHAR
    : ALPHA
    | '\u00C0'..'\u00D6'
    | '\u00D8'..'\u00F6'
    | '\u00F8'..'\u02FF'
    | '\u0370'..'\u037D'
    | '\u037F'..'\u1FFF'
    | '\u200C'..'\u200D'
    | '\u2070'..'\u218F'
    | '\u2C00'..'\u2FEF'
    | '\u3001'..'\uD7FF'
    | '\uF900'..'\uFDCF'
    | '\uFDF0'..'\uFFFD'
    | DIGIT
    | '_'
    | '-'
    | '\u00B7'           // as in the SPARQL 1.1 grammar
    | '\u203F'..'\u2040' // as in the SPARQL 1.1 grammar
    | ':'
    | '.' 
    ;



protected ID_START_CHAR 
    : ALPHA
    | '\u00C0'..'\u00D6'
    | '\u00D8'..'\u00F6'
    | '\u00F8'..'\u02FF'
    | '\u0370'..'\u037D'
    | '\u037F'..'\u1FFF'
    | '\u200C'..'\u200D'
    | '\u2070'..'\u218F'
    | '\u2C00'..'\u2FEF'
    | '\u3001'..'\uD7FF'
    | '\uF900'..'\uFDCF'
    | '\uFDF0'..'\uFFFD'
    | DIGIT
    | '_'
    ;
